<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>Repast HPC: repast::Context&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Repast HPC
   &#160;<span id="projectnumber">2.0</span>
   </div>
   <div id="projectbrief">High-Performance Agent-Based Modeling Platform</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>repast</b></li><li class="navelem"><a class="el" href="classrepast_1_1_context.html">Context</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classrepast_1_1_context-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">repast::Context&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Collection of agents of type T with set semantics.  
 <a href="classrepast_1_1_context.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_context_8h_source.html">Context.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for repast::Context&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classrepast_1_1_context.png" usemap="#repast::Context&lt; T &gt;_map" alt=""/>
  <map id="repast::Context&lt; T &gt;_map" name="repast::Context&lt; T &gt;_map">
<area href="classrepast_1_1_shared_context.html" title="Context implementation specialized for the parallel distributed simulation. " alt="repast::SharedContext&lt; T &gt;" shape="rect" coords="0,56,167,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a94c26538a555d9d781034b89cfa1cc8a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94c26538a555d9d781034b89cfa1cc8a"></a>
typedef <br class="typebreak"/>
boost::transform_iterator<br class="typebreak"/>
&lt; <a class="el" href="structrepast_1_1_second_element.html">SecondElement</a>&lt; T &gt;, typename <br class="typebreak"/>
AgentMap::const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="separator:a94c26538a555d9d781034b89cfa1cc8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27ec9bbfb365044a5088e1cdedc3ad1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac27ec9bbfb365044a5088e1cdedc3ad1"></a>
typedef boost::filter_iterator<br class="typebreak"/>
&lt; <a class="el" href="structrepast_1_1_is_agent_type.html">IsAgentType</a>&lt; T &gt;, typename <br class="typebreak"/>
<a class="el" href="classrepast_1_1_context.html">Context</a>&lt; T &gt;::const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_bytype_iterator</b></td></tr>
<tr class="separator:ac27ec9bbfb365044a5088e1cdedc3ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab86028066396e40cc29cfff8d54ee581"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab86028066396e40cc29cfff8d54ee581"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_context.html#ab86028066396e40cc29cfff8d54ee581">~Context</a> ()</td></tr>
<tr class="memdesc:ab86028066396e40cc29cfff8d54ee581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this context and the projections it contains. <br/></td></tr>
<tr class="separator:ab86028066396e40cc29cfff8d54ee581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0bc4b142fe7154c03d4e4bd2f6836ed"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_context.html#ad0bc4b142fe7154c03d4e4bd2f6836ed">addAgent</a> (T *agent)</td></tr>
<tr class="memdesc:ad0bc4b142fe7154c03d4e4bd2f6836ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the agent to the context.  <a href="#ad0bc4b142fe7154c03d4e4bd2f6836ed">More...</a><br/></td></tr>
<tr class="separator:ad0bc4b142fe7154c03d4e4bd2f6836ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d41e5246dc2940be3ea45f2a233487"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_context.html#a96d41e5246dc2940be3ea45f2a233487">addProjection</a> (<a class="el" href="classrepast_1_1_projection.html">Projection</a>&lt; T &gt; *projection)</td></tr>
<tr class="memdesc:a96d41e5246dc2940be3ea45f2a233487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the specified projection to this context.  <a href="#a96d41e5246dc2940be3ea45f2a233487">More...</a><br/></td></tr>
<tr class="separator:a96d41e5246dc2940be3ea45f2a233487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b60609163a2906e23d0b02bf76d7ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classrepast_1_1_projection.html">Projection</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_context.html#a10b60609163a2906e23d0b02bf76d7ac">getProjection</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a10b60609163a2906e23d0b02bf76d7ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the named <a class="el" href="classrepast_1_1_projection.html" title="Abstract base class for all Projections. ">Projection</a>.  <a href="#a10b60609163a2906e23d0b02bf76d7ac">More...</a><br/></td></tr>
<tr class="separator:a10b60609163a2906e23d0b02bf76d7ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef4c1e4a5f789b6402574fb2d8bd8ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_context.html#a7ef4c1e4a5f789b6402574fb2d8bd8ef">removeAgent</a> (const <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> id)</td></tr>
<tr class="memdesc:a7ef4c1e4a5f789b6402574fb2d8bd8ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the specified agent from this context.  <a href="#a7ef4c1e4a5f789b6402574fb2d8bd8ef">More...</a><br/></td></tr>
<tr class="separator:a7ef4c1e4a5f789b6402574fb2d8bd8ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad64ba451c47e2364f33e73b482a3a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ad64ba451c47e2364f33e73b482a3a4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_context.html#a1ad64ba451c47e2364f33e73b482a3a4">removeAgent</a> (T *agent)</td></tr>
<tr class="memdesc:a1ad64ba451c47e2364f33e73b482a3a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the specified agent from this context. <br/></td></tr>
<tr class="separator:a1ad64ba451c47e2364f33e73b482a3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ec330f6e930b4c83929a70df993b43"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_context.html#a72ec330f6e930b4c83929a70df993b43">getAgent</a> (const <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &amp;id)</td></tr>
<tr class="memdesc:a72ec330f6e930b4c83929a70df993b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the specified agent.  <a href="#a72ec330f6e930b4c83929a70df993b43">More...</a><br/></td></tr>
<tr class="separator:a72ec330f6e930b4c83929a70df993b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543dcc0f3ea4ecbe054232eaaa9c72e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_context.html#a543dcc0f3ea4ecbe054232eaaa9c72e4">getRandomAgents</a> (const int count, std::vector&lt; T * &gt; &amp;agents)</td></tr>
<tr class="memdesc:a543dcc0f3ea4ecbe054232eaaa9c72e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets at random the specified count of agents and returns them in the agents vector.  <a href="#a543dcc0f3ea4ecbe054232eaaa9c72e4">More...</a><br/></td></tr>
<tr class="separator:a543dcc0f3ea4ecbe054232eaaa9c72e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c69277c868b42ee0bb0d3b90a1df46d"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_context.html#a0c69277c868b42ee0bb0d3b90a1df46d">begin</a> () const </td></tr>
<tr class="memdesc:a0c69277c868b42ee0bb0d3b90a1df46d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the start of iterator over the agents in this context.  <a href="#a0c69277c868b42ee0bb0d3b90a1df46d">More...</a><br/></td></tr>
<tr class="separator:a0c69277c868b42ee0bb0d3b90a1df46d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af584236067222d8c1a2aa51b5e396da4"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_context.html#af584236067222d8c1a2aa51b5e396da4">end</a> () const </td></tr>
<tr class="memdesc:af584236067222d8c1a2aa51b5e396da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the end of an iterator over the agents in this context.  <a href="#af584236067222d8c1a2aa51b5e396da4">More...</a><br/></td></tr>
<tr class="separator:af584236067222d8c1a2aa51b5e396da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b77a55622dcdce4b82e8c2864642544"><td class="memItemLeft" align="right" valign="top">const_bytype_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_context.html#a2b77a55622dcdce4b82e8c2864642544">byTypeBegin</a> (int typeId) const </td></tr>
<tr class="memdesc:a2b77a55622dcdce4b82e8c2864642544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the start of an iterator over agents in this context of the specified type.  <a href="#a2b77a55622dcdce4b82e8c2864642544">More...</a><br/></td></tr>
<tr class="separator:a2b77a55622dcdce4b82e8c2864642544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e427063cdbfc5e37764291df2b2b53"><td class="memItemLeft" align="right" valign="top">const_bytype_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_context.html#aa7e427063cdbfc5e37764291df2b2b53">byTypeEnd</a> (int typeId) const </td></tr>
<tr class="memdesc:aa7e427063cdbfc5e37764291df2b2b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the end of an iterator over agents in this context of the specified type.  <a href="#aa7e427063cdbfc5e37764291df2b2b53">More...</a><br/></td></tr>
<tr class="separator:aa7e427063cdbfc5e37764291df2b2b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579cde2d1318e073f9fd068a7b0ed1a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a579cde2d1318e073f9fd068a7b0ed1a5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_context.html#a579cde2d1318e073f9fd068a7b0ed1a5">contains</a> (const <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &amp;id)</td></tr>
<tr class="memdesc:a579cde2d1318e073f9fd068a7b0ed1a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the specified agent is in this context, otherwise false. <br/></td></tr>
<tr class="separator:a579cde2d1318e073f9fd068a7b0ed1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86fbff836e4066f98c893157c76db88"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa86fbff836e4066f98c893157c76db88"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_context.html#aa86fbff836e4066f98c893157c76db88">size</a> () const </td></tr>
<tr class="memdesc:aa86fbff836e4066f98c893157c76db88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size (number of agents) in this context. <br/></td></tr>
<tr class="separator:aa86fbff836e4066f98c893157c76db88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9120a6aac361baa92d6dbd83410ff576"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_context.html#a9120a6aac361baa92d6dbd83410ff576">addValueLayer</a> (<a class="el" href="classrepast_1_1_base_value_layer.html">BaseValueLayer</a> *valueLayer)</td></tr>
<tr class="memdesc:a9120a6aac361baa92d6dbd83410ff576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a value layer to this context.  <a href="#a9120a6aac361baa92d6dbd83410ff576">More...</a><br/></td></tr>
<tr class="separator:a9120a6aac361baa92d6dbd83410ff576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e06221e76065ae8ee50815bb1a7a41"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename Borders &gt; </td></tr>
<tr class="memitem:ac4e06221e76065ae8ee50815bb1a7a41"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classrepast_1_1_discrete_value_layer.html">DiscreteValueLayer</a>&lt; ValueType, <br class="typebreak"/>
<a class="el" href="classrepast_1_1_borders.html">Borders</a> &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrepast_1_1_context.html#ac4e06221e76065ae8ee50815bb1a7a41">getDiscreteValueLayer</a> (const std::string &amp;valueLayerName)</td></tr>
<tr class="memdesc:ac4e06221e76065ae8ee50815bb1a7a41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the named discrete value layer from this <a class="el" href="classrepast_1_1_context.html" title="Collection of agents of type T with set semantics. ">Context</a>.  <a href="#ac4e06221e76065ae8ee50815bb1a7a41">More...</a><br/></td></tr>
<tr class="separator:ac4e06221e76065ae8ee50815bb1a7a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac760826f1f535b474af50dec727e9f"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename Borders &gt; </td></tr>
<tr class="memitem:a9ac760826f1f535b474af50dec727e9f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classrepast_1_1_continuous_value_layer.html">ContinuousValueLayer</a><br class="typebreak"/>
&lt; ValueType, <a class="el" href="classrepast_1_1_borders.html">Borders</a> &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrepast_1_1_context.html#a9ac760826f1f535b474af50dec727e9f">getContinuousValueLayer</a> (const std::string &amp;valueLayerName)</td></tr>
<tr class="memdesc:a9ac760826f1f535b474af50dec727e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the named continuous value layer from this <a class="el" href="classrepast_1_1_context.html" title="Collection of agents of type T with set semantics. ">Context</a>.  <a href="#a9ac760826f1f535b474af50dec727e9f">More...</a><br/></td></tr>
<tr class="separator:a9ac760826f1f535b474af50dec727e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54a094afb5834a34be46e732465ff30"><td class="memTemplParams" colspan="2">template&lt;typename filterStruct &gt; </td></tr>
<tr class="memitem:ab54a094afb5834a34be46e732465ff30"><td class="memTemplItemLeft" align="right" valign="top">boost::filter_iterator<br class="typebreak"/>
&lt; filterStruct, typename <br class="typebreak"/>
<a class="el" href="classrepast_1_1_context.html">Context</a>&lt; T &gt;::const_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrepast_1_1_context.html#ab54a094afb5834a34be46e732465ff30">filteredBegin</a> (const filterStruct &amp;fStruct)</td></tr>
<tr class="memdesc:ab54a094afb5834a34be46e732465ff30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a filtered iterator over the set of agents in this context and returns it with a value equal to the beginning of the list.  <a href="#ab54a094afb5834a34be46e732465ff30">More...</a><br/></td></tr>
<tr class="separator:ab54a094afb5834a34be46e732465ff30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12bb3d7e2578bf80ebbd0dd1b1a7ebd"><td class="memTemplParams" colspan="2">template&lt;typename filterStruct &gt; </td></tr>
<tr class="memitem:ad12bb3d7e2578bf80ebbd0dd1b1a7ebd"><td class="memTemplItemLeft" align="right" valign="top">boost::filter_iterator<br class="typebreak"/>
&lt; filterStruct, typename <br class="typebreak"/>
<a class="el" href="classrepast_1_1_context.html">Context</a>&lt; T &gt;::const_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrepast_1_1_context.html#ad12bb3d7e2578bf80ebbd0dd1b1a7ebd">filteredEnd</a> (const filterStruct &amp;fStruct)</td></tr>
<tr class="memdesc:ad12bb3d7e2578bf80ebbd0dd1b1a7ebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a filtered iterator over the set of agents in this context and returns it with a value equal to one step past end of the list.  <a href="#ad12bb3d7e2578bf80ebbd0dd1b1a7ebd">More...</a><br/></td></tr>
<tr class="separator:ad12bb3d7e2578bf80ebbd0dd1b1a7ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7abe8aefbda43b0b35fcbd3589b465c"><td class="memTemplParams" colspan="2">template&lt;typename filterStruct &gt; </td></tr>
<tr class="memitem:aa7abe8aefbda43b0b35fcbd3589b465c"><td class="memTemplItemLeft" align="right" valign="top">boost::filter_iterator<br class="typebreak"/>
&lt; filterStruct, typename <br class="typebreak"/>
<a class="el" href="classrepast_1_1_context.html">Context</a>&lt; T &gt;<br class="typebreak"/>
::const_bytype_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrepast_1_1_context.html#aa7abe8aefbda43b0b35fcbd3589b465c">byTypeFilteredBegin</a> (const int type, const filterStruct &amp;fStruct)</td></tr>
<tr class="memdesc:aa7abe8aefbda43b0b35fcbd3589b465c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a filtered iterator over the set of agents in this context of the specified type (per their <a class="el" href="classrepast_1_1_agent_id.html" title="Agent identity information. ">AgentId</a> values), and returns it with a value equal to the beginning of the list.  <a href="#aa7abe8aefbda43b0b35fcbd3589b465c">More...</a><br/></td></tr>
<tr class="separator:aa7abe8aefbda43b0b35fcbd3589b465c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94cee2bd8c4325a7fe79048c0f12a5b6"><td class="memTemplParams" colspan="2">template&lt;typename filterStruct &gt; </td></tr>
<tr class="memitem:a94cee2bd8c4325a7fe79048c0f12a5b6"><td class="memTemplItemLeft" align="right" valign="top">boost::filter_iterator<br class="typebreak"/>
&lt; filterStruct, typename <br class="typebreak"/>
<a class="el" href="classrepast_1_1_context.html">Context</a>&lt; T &gt;<br class="typebreak"/>
::const_bytype_iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrepast_1_1_context.html#a94cee2bd8c4325a7fe79048c0f12a5b6">byTypeFilteredEnd</a> (const int type, const filterStruct &amp;fStruct)</td></tr>
<tr class="memdesc:a94cee2bd8c4325a7fe79048c0f12a5b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a filtered iterator over the set of agents in this context of the specified type (per their <a class="el" href="classrepast_1_1_agent_id.html" title="Agent identity information. ">AgentId</a> values), and returns it with a value equal to one past the end of the list.  <a href="#a94cee2bd8c4325a7fe79048c0f12a5b6">More...</a><br/></td></tr>
<tr class="separator:a94cee2bd8c4325a7fe79048c0f12a5b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f389ebd5bea672d5d7d14ffba5b710f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_context.html#a6f389ebd5bea672d5d7d14ffba5b710f">selectAgents</a> (std::set&lt; T * &gt; &amp;selectedAgents, bool remove=false)</td></tr>
<tr class="memdesc:a6f389ebd5bea672d5d7d14ffba5b710f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a set of pointers to all agents in this context.  <a href="#a6f389ebd5bea672d5d7d14ffba5b710f">More...</a><br/></td></tr>
<tr class="separator:a6f389ebd5bea672d5d7d14ffba5b710f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc9180a8ff5e079ca37edb08a434ff9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_context.html#aacc9180a8ff5e079ca37edb08a434ff9">selectAgents</a> (std::vector&lt; T * &gt; &amp;selectedAgents, bool remove=false)</td></tr>
<tr class="memdesc:aacc9180a8ff5e079ca37edb08a434ff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a randomly ordered vector of pointers to all agents in this context.  <a href="#aacc9180a8ff5e079ca37edb08a434ff9">More...</a><br/></td></tr>
<tr class="separator:aacc9180a8ff5e079ca37edb08a434ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305bd5cfc509be346842567fdf72f97d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_context.html#a305bd5cfc509be346842567fdf72f97d">selectAgents</a> (int count, std::set&lt; T * &gt; &amp;selectedAgents, bool remove=false)</td></tr>
<tr class="memdesc:a305bd5cfc509be346842567fdf72f97d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a set of pointers to a specified number of randomly selected agents.  <a href="#a305bd5cfc509be346842567fdf72f97d">More...</a><br/></td></tr>
<tr class="separator:a305bd5cfc509be346842567fdf72f97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba9351838355a0cfe3dff074448bbc5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_context.html#acba9351838355a0cfe3dff074448bbc5">selectAgents</a> (int count, std::vector&lt; T * &gt; &amp;selectedAgents, bool remove=false)</td></tr>
<tr class="memdesc:acba9351838355a0cfe3dff074448bbc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a randomly ordered vector of pointers to a specified number of randomly selected agents.  <a href="#acba9351838355a0cfe3dff074448bbc5">More...</a><br/></td></tr>
<tr class="separator:acba9351838355a0cfe3dff074448bbc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2012f09fb75bfdeb798431e63edfde"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_context.html#abf2012f09fb75bfdeb798431e63edfde">selectAgents</a> (std::set&lt; T * &gt; &amp;selectedAgents, int type, bool remove=false, int popSize=-1)</td></tr>
<tr class="memdesc:abf2012f09fb75bfdeb798431e63edfde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a set of pointers to all agents in this context of a specified type (per their <a class="el" href="classrepast_1_1_agent_id.html" title="Agent identity information. ">AgentId</a> values).  <a href="#abf2012f09fb75bfdeb798431e63edfde">More...</a><br/></td></tr>
<tr class="separator:abf2012f09fb75bfdeb798431e63edfde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ca3deb5e820bf84df1dd83fdd14f2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_context.html#af8ca3deb5e820bf84df1dd83fdd14f2d">selectAgents</a> (std::vector&lt; T * &gt; &amp;selectedAgents, int type, bool remove=false, int popSize=-1)</td></tr>
<tr class="memdesc:af8ca3deb5e820bf84df1dd83fdd14f2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a randomly ordered vector of pointers to all agents in this context of a specified type (per their <a class="el" href="classrepast_1_1_agent_id.html" title="Agent identity information. ">AgentId</a> values).  <a href="#af8ca3deb5e820bf84df1dd83fdd14f2d">More...</a><br/></td></tr>
<tr class="separator:af8ca3deb5e820bf84df1dd83fdd14f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8961d3bd4575afac3ef571166739ac39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_context.html#a8961d3bd4575afac3ef571166739ac39">selectAgents</a> (int count, std::set&lt; T * &gt; &amp;selectedAgents, int type, bool remove=false, int popSize=-1)</td></tr>
<tr class="memdesc:a8961d3bd4575afac3ef571166739ac39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a set of pointers to a specified number of randomly selected agents of a specified type (per their <a class="el" href="classrepast_1_1_agent_id.html" title="Agent identity information. ">AgentId</a> values).  <a href="#a8961d3bd4575afac3ef571166739ac39">More...</a><br/></td></tr>
<tr class="separator:a8961d3bd4575afac3ef571166739ac39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae94abf702a7223aaadc74da4f1fd639"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_context.html#aae94abf702a7223aaadc74da4f1fd639">selectAgents</a> (int count, std::vector&lt; T * &gt; &amp;selectedAgents, int type, bool remove=false, int popSize=-1)</td></tr>
<tr class="memdesc:aae94abf702a7223aaadc74da4f1fd639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a randomly ordered vector of pointers to a specified number of randomly selected agents of a specified type (per their <a class="el" href="classrepast_1_1_agent_id.html" title="Agent identity information. ">AgentId</a> values).  <a href="#aae94abf702a7223aaadc74da4f1fd639">More...</a><br/></td></tr>
<tr class="separator:aae94abf702a7223aaadc74da4f1fd639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926168c2e765e58473d901f56a6a42f7"><td class="memTemplParams" colspan="2">template&lt;typename filterStruct &gt; </td></tr>
<tr class="memitem:a926168c2e765e58473d901f56a6a42f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrepast_1_1_context.html#a926168c2e765e58473d901f56a6a42f7">selectAgents</a> (std::set&lt; T * &gt; &amp;selectedAgents, filterStruct &amp;filter, bool remove=false, int popSize=-1)</td></tr>
<tr class="memdesc:a926168c2e765e58473d901f56a6a42f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a set of pointers to all agents in this context matching a user-defined filter.  <a href="#a926168c2e765e58473d901f56a6a42f7">More...</a><br/></td></tr>
<tr class="separator:a926168c2e765e58473d901f56a6a42f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5011ce09dc44040c235b176261defcf3"><td class="memTemplParams" colspan="2">template&lt;typename filterStruct &gt; </td></tr>
<tr class="memitem:a5011ce09dc44040c235b176261defcf3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrepast_1_1_context.html#a5011ce09dc44040c235b176261defcf3">selectAgents</a> (std::vector&lt; T * &gt; &amp;selectedAgents, filterStruct &amp;filter, bool remove=false, int popSize=-1)</td></tr>
<tr class="memdesc:a5011ce09dc44040c235b176261defcf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a randomly ordered vector of pointers to all agents in this context matching a user-defined filter.  <a href="#a5011ce09dc44040c235b176261defcf3">More...</a><br/></td></tr>
<tr class="separator:a5011ce09dc44040c235b176261defcf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10218ffcf74884be4e12c49a26106878"><td class="memTemplParams" colspan="2">template&lt;typename filterStruct &gt; </td></tr>
<tr class="memitem:a10218ffcf74884be4e12c49a26106878"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrepast_1_1_context.html#a10218ffcf74884be4e12c49a26106878">selectAgents</a> (int count, std::set&lt; T * &gt; &amp;selectedAgents, filterStruct &amp;filter, bool remove=false, int popSize=-1)</td></tr>
<tr class="memdesc:a10218ffcf74884be4e12c49a26106878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a set of pointers to a specified number of randomly selected agents matching a user-defined filter.  <a href="#a10218ffcf74884be4e12c49a26106878">More...</a><br/></td></tr>
<tr class="separator:a10218ffcf74884be4e12c49a26106878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41673cd1e0623849d505884afaaf2581"><td class="memTemplParams" colspan="2">template&lt;typename filterStruct &gt; </td></tr>
<tr class="memitem:a41673cd1e0623849d505884afaaf2581"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrepast_1_1_context.html#a41673cd1e0623849d505884afaaf2581">selectAgents</a> (int count, std::vector&lt; T * &gt; &amp;selectedAgents, filterStruct &amp;filter, bool remove=false, int popSize=-1)</td></tr>
<tr class="memdesc:a41673cd1e0623849d505884afaaf2581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a randomly ordered vector of pointers to a specified number of randomly selected agents matching a user-defined filter.  <a href="#a41673cd1e0623849d505884afaaf2581">More...</a><br/></td></tr>
<tr class="separator:a41673cd1e0623849d505884afaaf2581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d678fd5e8a320db144d17fb863ee91a"><td class="memTemplParams" colspan="2">template&lt;typename filterStruct &gt; </td></tr>
<tr class="memitem:a2d678fd5e8a320db144d17fb863ee91a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrepast_1_1_context.html#a2d678fd5e8a320db144d17fb863ee91a">selectAgents</a> (std::set&lt; T * &gt; &amp;selectedAgents, int type, filterStruct &amp;filter, bool remove=false, int popSize=-1)</td></tr>
<tr class="memdesc:a2d678fd5e8a320db144d17fb863ee91a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a set of pointers to all agents in this context of a specified type (per their <a class="el" href="classrepast_1_1_agent_id.html" title="Agent identity information. ">AgentId</a> values) and matching a user-defined filter.  <a href="#a2d678fd5e8a320db144d17fb863ee91a">More...</a><br/></td></tr>
<tr class="separator:a2d678fd5e8a320db144d17fb863ee91a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07cf00b1c5a00b676c5de83e8db438aa"><td class="memTemplParams" colspan="2">template&lt;typename filterStruct &gt; </td></tr>
<tr class="memitem:a07cf00b1c5a00b676c5de83e8db438aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrepast_1_1_context.html#a07cf00b1c5a00b676c5de83e8db438aa">selectAgents</a> (std::vector&lt; T * &gt; &amp;selectedAgents, int type, filterStruct &amp;filter, bool remove=false, int popSize=-1)</td></tr>
<tr class="memdesc:a07cf00b1c5a00b676c5de83e8db438aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a randomly ordered vector of pointers to all agents in this context of a specified type (per their <a class="el" href="classrepast_1_1_agent_id.html" title="Agent identity information. ">AgentId</a> values) and matching a user-defined filter.  <a href="#a07cf00b1c5a00b676c5de83e8db438aa">More...</a><br/></td></tr>
<tr class="separator:a07cf00b1c5a00b676c5de83e8db438aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe8f496266275c9edb065c06c6574fc1"><td class="memTemplParams" colspan="2">template&lt;typename filterStruct &gt; </td></tr>
<tr class="memitem:afe8f496266275c9edb065c06c6574fc1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrepast_1_1_context.html#afe8f496266275c9edb065c06c6574fc1">selectAgents</a> (int count, std::set&lt; T * &gt; &amp;selectedAgents, int type, filterStruct &amp;filter, bool remove=false, int popSize=-1)</td></tr>
<tr class="memdesc:afe8f496266275c9edb065c06c6574fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a set of pointers to a specified number of randomly selected agents of a specified type (per their <a class="el" href="classrepast_1_1_agent_id.html" title="Agent identity information. ">AgentId</a> values) and matching a user-defined filter.  <a href="#afe8f496266275c9edb065c06c6574fc1">More...</a><br/></td></tr>
<tr class="separator:afe8f496266275c9edb065c06c6574fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4aea4be7eaf1c4be741a371e90057a9"><td class="memTemplParams" colspan="2">template&lt;typename filterStruct &gt; </td></tr>
<tr class="memitem:ab4aea4be7eaf1c4be741a371e90057a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrepast_1_1_context.html#ab4aea4be7eaf1c4be741a371e90057a9">selectAgents</a> (int count, std::vector&lt; T * &gt; &amp;selectedAgents, int type, filterStruct &amp;filter, bool remove=false, int popSize=-1)</td></tr>
<tr class="memdesc:ab4aea4be7eaf1c4be741a371e90057a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a randomly ordered vector of pointers to a specified number of randomly selected agents of a specified type (per their <a class="el" href="classrepast_1_1_agent_id.html" title="Agent identity information. ">AgentId</a> values) and matching a user-defined filter.  <a href="#ab4aea4be7eaf1c4be741a371e90057a9">More...</a><br/></td></tr>
<tr class="separator:ab4aea4be7eaf1c4be741a371e90057a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a420350cd434f4e0f30a3d41c93298f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_context.html#a8a420350cd434f4e0f30a3d41c93298f">getProjectionInfo</a> (<a class="el" href="classrepast_1_1_agent_request.html">AgentRequest</a> req, std::map&lt; std::string, std::vector&lt; <a class="el" href="classrepast_1_1_projection_info_packet.html">repast::ProjectionInfoPacket</a> * &gt; &gt; &amp;map, bool secondaryInfo=false, std::set&lt; <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &gt; *secondaryIds=0, int destProc=-1)</td></tr>
<tr class="memdesc:a8a420350cd434f4e0f30a3d41c93298f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the projection information for all projections in this context, for all agents whose IDs are listed in the <a class="el" href="classrepast_1_1_agent_request.html" title="Encapsulates a request made by one process for agents in another. ">AgentRequest</a>.  <a href="#a8a420350cd434f4e0f30a3d41c93298f">More...</a><br/></td></tr>
<tr class="separator:a8a420350cd434f4e0f30a3d41c93298f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9470dbe20a0b4243d52edea86c213feb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrepast_1_1_context.html#a9470dbe20a0b4243d52edea86c213feb">setProjectionInfo</a> (std::map&lt; std::string, std::vector&lt; <a class="el" href="classrepast_1_1_projection_info_packet.html">repast::ProjectionInfoPacket</a> * &gt; &gt; &amp;projInfo)</td></tr>
<tr class="memdesc:a9470dbe20a0b4243d52edea86c213feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the projection information as specified.  <a href="#a9470dbe20a0b4243d52edea86c213feb">More...</a><br/></td></tr>
<tr class="separator:a9470dbe20a0b4243d52edea86c213feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88097fca27376b1fc460bb75f47869bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88097fca27376b1fc460bb75f47869bb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cleanProjectionInfo</b> (std::set&lt; <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &gt; &amp;agentsToKeep)</td></tr>
<tr class="separator:a88097fca27376b1fc460bb75f47869bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aed0c509cff2035ca99c2b2fc299dcca0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed0c509cff2035ca99c2b2fc299dcca0"></a>
std::vector&lt; <a class="el" href="classrepast_1_1_projection.html">Projection</a>&lt; T &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>projections</b></td></tr>
<tr class="separator:aed0c509cff2035ca99c2b2fc299dcca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br/>
class repast::Context&lt; T &gt;</h3>

<p>Collection of agents of type T with set semantics. </p>
<p>Object identity and equality is determined by their <a class="el" href="classrepast_1_1_agent_id.html" title="Agent identity information. ">AgentId</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">the</td><td>type objects contained by the <a class="el" href="classrepast_1_1_context.html" title="Collection of agents of type T with set semantics. ">Context</a>. The T must extends <a class="el" href="classrepast_1_1_agent.html" title="Interface for agent classes. ">repast::Agent</a>. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad0bc4b142fe7154c03d4e4bd2f6836ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="classrepast_1_1_context.html">repast::Context</a>&lt; T &gt;::addAgent </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>agent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the agent to the context. </p>
<p>Performs a check to ensure that no agent with the same ID (presumably the 'same' agent) has previously been added. If a matching ID is found, the new agent is not added, and the address of the pre-existing agent is returned. If no match is found, the agent is added and the return value is the same as the value passed</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">agent</td><td>the agent to add</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the address of the agent in the context; will be the same as the address passed if the agent was successfully added, but if there was already an agent with the same ID the address returned will be that of the pre-existing agent, which is not replaced. </dd></dl>

</div>
</div>
<a class="anchor" id="a96d41e5246dc2940be3ea45f2a233487"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrepast_1_1_context.html">repast::Context</a>&lt; T &gt;::addProjection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrepast_1_1_projection.html">Projection</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>projection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the specified projection to this context. </p>
<p>All the agents in this context will be added to the <a class="el" href="classrepast_1_1_projection.html" title="Abstract base class for all Projections. ">Projection</a>. Any agents subsequently added to this context will also be added to the <a class="el" href="classrepast_1_1_projection.html" title="Abstract base class for all Projections. ">Projection</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">projection</td><td>the projection to add </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classrepast_1_1_shared_context.html#af8f235d4d8e4b1efc548ea8a5b1ab75d">repast::SharedContext&lt; T &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a9120a6aac361baa92d6dbd83410ff576"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrepast_1_1_context.html">repast::Context</a>&lt; T &gt;::addValueLayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrepast_1_1_base_value_layer.html">BaseValueLayer</a> *&#160;</td>
          <td class="paramname"><em>valueLayer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a value layer to this context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valueLayer</td><td>the value layer to add </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0c69277c868b42ee0bb0d3b90a1df46d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classrepast_1_1_context.html">repast::Context</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the start of iterator over the agents in this context. </p>
<p>The iterator derefrences into shared_ptr&lt;T&gt;. The actual agent can be accessed by derefrenceing the iter: (*iter)-&gt;getId() for example.</p>
<dl class="section return"><dt>Returns</dt><dd>the start of iterator over the agents in this context. </dd></dl>

</div>
</div>
<a class="anchor" id="a2b77a55622dcdce4b82e8c2864642544"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_bytype_iterator <a class="el" href="classrepast_1_1_context.html">repast::Context</a>&lt; T &gt;::byTypeBegin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>typeId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the start of an iterator over agents in this context of the specified type. </p>
<p>The type corresponds to the type component of an agent's <a class="el" href="classrepast_1_1_agent_id.html" title="Agent identity information. ">AgentId</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">typeId</td><td>the type of the agent. Only Agents whose agentId.agentType() is equal to this typeId will be included in the iterator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the start of an iterator over agents in this context of the specified type. </dd></dl>

</div>
</div>
<a class="anchor" id="aa7e427063cdbfc5e37764291df2b2b53"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_bytype_iterator <a class="el" href="classrepast_1_1_context.html">repast::Context</a>&lt; T &gt;::byTypeEnd </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>typeId</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the end of an iterator over agents in this context of the specified type. </p>
<p>The type corresponds to the type component of an agent's <a class="el" href="classrepast_1_1_agent_id.html" title="Agent identity information. ">AgentId</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">typeId</td><td>the type of the agent. Only Agents whose agentId.agentType() is equal to this typeId will be included in the iterator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the end of an iterator over agents in this context of the specified type. </dd></dl>

</div>
</div>
<a class="anchor" id="aa7abe8aefbda43b0b35fcbd3589b465c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename filterStruct &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::filter_iterator&lt; filterStruct, typename <a class="el" href="classrepast_1_1_context.html">Context</a>&lt; T &gt;::const_bytype_iterator &gt; <a class="el" href="classrepast_1_1_context.html">repast::Context</a>&lt; T &gt;::byTypeFilteredBegin </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const filterStruct &amp;&#160;</td>
          <td class="paramname"><em>fStruct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a filtered iterator over the set of agents in this context of the specified type (per their <a class="el" href="classrepast_1_1_agent_id.html" title="Agent identity information. ">AgentId</a> values), and returns it with a value equal to the beginning of the list. </p>
<p>The struct can be any user-defined structure that implements a unary operator (see <a class="el" href="structrepast_1_1_is_agent_type.html" title="Struct that allows filtering by Agent Type. ">IsAgentType</a>) that can be passed and which will become a filter to sort across the agent list, e.g.:</p>
<p>struct filter { bool operator()(const boost::shared_ptr&lt;T&gt;&amp; ptr){ return (ptr-&gt;getAgentValue() == targetValue;) } }</p>
<p>This should allow filtering of agents by type and on any attribute.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fStruct</td><td>an instance of the struct to be used as the filter </td></tr>
    <tr><td class="paramname">type</td><td>the numeric type of agents to be included in the list</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">filterStruct</td><td>the type of the filter to be applied to the agents</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator positioned at the beginning of the list of agents meeting the filter's criteria </dd></dl>

</div>
</div>
<a class="anchor" id="a94cee2bd8c4325a7fe79048c0f12a5b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename filterStruct &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::filter_iterator&lt; filterStruct, typename <a class="el" href="classrepast_1_1_context.html">Context</a>&lt; T &gt;::const_bytype_iterator &gt; <a class="el" href="classrepast_1_1_context.html">repast::Context</a>&lt; T &gt;::byTypeFilteredEnd </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const filterStruct &amp;&#160;</td>
          <td class="paramname"><em>fStruct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a filtered iterator over the set of agents in this context of the specified type (per their <a class="el" href="classrepast_1_1_agent_id.html" title="Agent identity information. ">AgentId</a> values), and returns it with a value equal to one past the end of the list. </p>
<p>The struct can be any user-defined structure that implements a unary operator (see <a class="el" href="structrepast_1_1_is_agent_type.html" title="Struct that allows filtering by Agent Type. ">IsAgentType</a>) that can be passed and which will become a filter to sort across the agent list, e.g.:</p>
<p>struct filter { bool operator()(const boost::shared_ptr&lt;T&gt;&amp; ptr){ return (ptr-&gt;getAgentValue() == targetValue;) } }</p>
<p>This should allow filtering of agents by type and on any attribute.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fStruct</td><td>an instance of the struct to be used as the filter </td></tr>
    <tr><td class="paramname">type</td><td>the numeric type of agents to be included in the list</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">filterStruct</td><td>the type of the filter to be applied to the agents</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator positioned at one past the end of the list of agents meeting the filter's criteria </dd></dl>

</div>
</div>
<a class="anchor" id="af584236067222d8c1a2aa51b5e396da4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classrepast_1_1_context.html">repast::Context</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the end of an iterator over the agents in this context. </p>
<p>The iterator derefrences into shared_ptr&lt;T&gt;. The actual agent can be accessed by derefrenceing the iter: (*iter)-&gt;getId() for example.</p>
<dl class="section return"><dt>Returns</dt><dd>the end of an iterator over the agents in this context </dd></dl>

</div>
</div>
<a class="anchor" id="ab54a094afb5834a34be46e732465ff30"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename filterStruct &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::filter_iterator&lt; filterStruct, typename <a class="el" href="classrepast_1_1_context.html">Context</a>&lt; T &gt;::const_iterator &gt; <a class="el" href="classrepast_1_1_context.html">repast::Context</a>&lt; T &gt;::filteredBegin </td>
          <td>(</td>
          <td class="paramtype">const filterStruct &amp;&#160;</td>
          <td class="paramname"><em>fStruct</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a filtered iterator over the set of agents in this context and returns it with a value equal to the beginning of the list. </p>
<p>The struct can be any user-defined structure that implements a unary operator (see <a class="el" href="structrepast_1_1_is_agent_type.html" title="Struct that allows filtering by Agent Type. ">IsAgentType</a>) that can be passed and which will become a filter to sort across the agent list, e.g.:</p>
<p>struct filter { bool operator()(const boost::shared_ptr&lt;T&gt;&amp; ptr){ return (ptr-&gt;getAgentValue() == targetValue;) } }</p>
<p>This should allow filtering of agents by any attribute.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fStruct</td><td>an instance of the struct to be used as the filter</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">filterStruct</td><td>the type of the filter to be applied to the agents</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator positioned at the beginning of the list of agents meeting the filter's criteria </dd></dl>

</div>
</div>
<a class="anchor" id="ad12bb3d7e2578bf80ebbd0dd1b1a7ebd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename filterStruct &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::filter_iterator&lt; filterStruct, typename <a class="el" href="classrepast_1_1_context.html">Context</a>&lt; T &gt;::const_iterator &gt; <a class="el" href="classrepast_1_1_context.html">repast::Context</a>&lt; T &gt;::filteredEnd </td>
          <td>(</td>
          <td class="paramtype">const filterStruct &amp;&#160;</td>
          <td class="paramname"><em>fStruct</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a filtered iterator over the set of agents in this context and returns it with a value equal to one step past end of the list. </p>
<p>The struct can be any user-defined structure that implements a unary operator (see <a class="el" href="structrepast_1_1_is_agent_type.html" title="Struct that allows filtering by Agent Type. ">IsAgentType</a>) that can be passed and which will become a filter to sort across the agent list, e.g.:</p>
<p>struct filter { bool operator()(const boost::shared_ptr&lt;T&gt;&amp; ptr){ return (ptr-&gt;getAgentValue() == targetValue;) } }</p>
<p>This should allow filtering of agents by any attribute.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fStruct</td><td>an instance of the struct to be used as the filter</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">filterStruct</td><td>the type of the filter to be applied to the agents</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator positioned at one past the end of the list of agents meeting the filter's criteria </dd></dl>

</div>
</div>
<a class="anchor" id="a72ec330f6e930b4c83929a70df993b43"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="classrepast_1_1_context.html">repast::Context</a>&lt; T &gt;::getAgent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the specified agent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the</td><td>id of the agent to get. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9ac760826f1f535b474af50dec727e9f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename ValueType , typename Borders &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrepast_1_1_continuous_value_layer.html">ContinuousValueLayer</a>&lt; ValueType, <a class="el" href="classrepast_1_1_borders.html">Borders</a> &gt; * <a class="el" href="classrepast_1_1_context.html">repast::Context</a>&lt; T &gt;::getContinuousValueLayer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>valueLayerName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the named continuous value layer from this <a class="el" href="classrepast_1_1_context.html" title="Collection of agents of type T with set semantics. ">Context</a>. </p>
<p>The value layer must have been previously added.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valueLayerName</td><td>the name of the value layer to get</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>the numeric type contained by the value layer </td></tr>
    <tr><td class="paramname"><a class="el" href="classrepast_1_1_borders.html" title="Base class for representations of border semantics (e.g. ">Borders</a></td><td>the Border type of the value layer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the named continuous value layer from this <a class="el" href="classrepast_1_1_context.html" title="Collection of agents of type T with set semantics. ">Context</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ac4e06221e76065ae8ee50815bb1a7a41"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename ValueType , typename Borders &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrepast_1_1_discrete_value_layer.html">DiscreteValueLayer</a>&lt; ValueType, <a class="el" href="classrepast_1_1_borders.html">Borders</a> &gt; * <a class="el" href="classrepast_1_1_context.html">repast::Context</a>&lt; T &gt;::getDiscreteValueLayer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>valueLayerName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the named discrete value layer from this <a class="el" href="classrepast_1_1_context.html" title="Collection of agents of type T with set semantics. ">Context</a>. </p>
<p>The value layer must have been previously added.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">valueLayerName</td><td>the name of the value layer to get</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>the numeric type contained by the value layer </td></tr>
    <tr><td class="paramname"><a class="el" href="classrepast_1_1_borders.html" title="Base class for representations of border semantics (e.g. ">Borders</a></td><td>the Border type of the value layer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the named discrete value layer from this <a class="el" href="classrepast_1_1_context.html" title="Collection of agents of type T with set semantics. ">Context</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a10b60609163a2906e23d0b02bf76d7ac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrepast_1_1_projection.html">Projection</a>&lt; T &gt; * <a class="el" href="classrepast_1_1_context.html">repast::Context</a>&lt; T &gt;::getProjection </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the named <a class="el" href="classrepast_1_1_projection.html" title="Abstract base class for all Projections. ">Projection</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the</td><td>name of the projection to get</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the named <a class="el" href="classrepast_1_1_projection.html" title="Abstract base class for all Projections. ">Projection</a> or 0 if no such <a class="el" href="classrepast_1_1_projection.html" title="Abstract base class for all Projections. ">Projection</a> is found. </dd></dl>

</div>
</div>
<a class="anchor" id="a8a420350cd434f4e0f30a3d41c93298f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrepast_1_1_context.html">repast::Context</a>&lt; T &gt;::getProjectionInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrepast_1_1_agent_request.html">AgentRequest</a>&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, std::vector&lt; <a class="el" href="classrepast_1_1_projection_info_packet.html">repast::ProjectionInfoPacket</a> * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>secondaryInfo</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a> &gt; *&#160;</td>
          <td class="paramname"><em>secondaryIds</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destProc</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the projection information for all projections in this context, for all agents whose IDs are listed in the <a class="el" href="classrepast_1_1_agent_request.html" title="Encapsulates a request made by one process for agents in another. ">AgentRequest</a>. </p>
<p>The general sense of this method can be easily understood: given a list of agents, get the projection information for all of those agents. But there are some subtleties that should be kept in mind.</p>
<p>"The projection information for an agent" is misleading. In fact, the projection information that is needed can vary depending on the context and on the kind of projection.</p>
<p>Generally speaking, spaces return only one kind projection information: coordinate locations for the agent specified. This is the simplest case.</p>
<p>The more complicated case is given by graphs. A graph projection can return different sets of information depending on how that information will have to be used. The basic issue is that a graph projection returns sets of edges, and edges must be connected to other agents; this means that a mechanism must be in place for ensuring that the projection info that arrives can be used, which means that for a given 'ego' agent, all 'alter' agents that are connected to it by edges must also be on the receiving process. (Note: Repast HPC 1.0 versions sent all of the alter agents' content along with the edge send; this version does not do this, partly to minimize the amount of information being packaged and sent but also because the alternative method used is integrated with the normal bookkeeping for sharing agent information across processes (AgentRequests).) In different circumstances, different assumptions can be made about what information will be available on the receiving process. Note that the coordinate information is generally referred to as 'Primary' information, while edge information is 'secondary'; in a third category ('secondary IDs') are the IDs of the alter agents, which can be packaged separately.</p>
<p>The impact of this is that this function is generally called in the following ways:</p>
<p>1) When requesting agents: in this case, a copy of the agent will be sent from one process to another. No secondary information will be sent at all. This is because it is assumed that if an agent participated in a graph on the receiving process, it would already be present on that process and would not be being requested.</p>
<p>2) When synchronizing <a class="el" href="classrepast_1_1_projection.html" title="Abstract base class for all Projections. ">Projection</a> Information: in this case, some secondary information (edges) is needed: the edges that connect the specified ego agent with edges on the receiving process. No secondary IDs are needed, because the only edges being sent are those that connect to agents on the receiving process, which will be assumed to already be available on that process.</p>
<p>3) When synchronizing <a class="el" href="classrepast_1_1_agent.html" title="Interface for agent classes. ">Agent</a> Status (moving agents from process to process): in this case, the full collection of projection information is needed, including all of the edges in which the specified agent participates and all of the secondary IDs. (The secondary IDs of agents that are already on the receiving process can be omitted, at least theoretically.) This allows the full reconstruction of <a class="el" href="classrepast_1_1_projection.html" title="Abstract base class for all Projections. ">Projection</a> Information on the receiving process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>List of IDs for agents whose information is requested </td></tr>
    <tr><td class="paramname">map</td><td>A map into which the projection information will be placed. Key values represent the names of the projections in this context. </td></tr>
    <tr><td class="paramname">secondaryInfo</td><td>true if the 'secondary' projection info must also be returned </td></tr>
    <tr><td class="paramname">secondaryIds</td><td>A set of IDs for agents who are referred to by the projection informaton being returned (may be null) </td></tr>
    <tr><td class="paramname">destProc</td><td>The Process that will be receiving this information (the information sent may be customized depending on the destination process). If not specified a larger set of information will be sent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a543dcc0f3ea4ecbe054232eaaa9c72e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrepast_1_1_context.html">repast::Context</a>&lt; T &gt;::getRandomAgents </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T * &gt; &amp;&#160;</td>
          <td class="paramname"><em>agents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets at random the specified count of agents and returns them in the agents vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">count</td><td>the number of agents to get </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">agents</td><td>a vector where the agents will be returned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7ef4c1e4a5f789b6402574fb2d8bd8ef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrepast_1_1_context.html">repast::Context</a>&lt; T &gt;::removeAgent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classrepast_1_1_agent_id.html">AgentId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the specified agent from this context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the id of the agent to remove </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6f389ebd5bea672d5d7d14ffba5b710f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrepast_1_1_context.html">repast::Context</a>&lt; T &gt;::selectAgents </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; T * &gt; &amp;&#160;</td>
          <td class="paramname"><em>selectedAgents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remove</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a set of pointers to all agents in this context. </p>
<p>If the 'remove' parameter is set to true, any elements in the original set will be removed before the method returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">selectedAgents</td><td>a set into which the pointers to the agents will be placed </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">remove</td><td>if true, remove any elements originally in the set before the set is returned (default is false) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aacc9180a8ff5e079ca37edb08a434ff9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrepast_1_1_context.html">repast::Context</a>&lt; T &gt;::selectAgents </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T * &gt; &amp;&#160;</td>
          <td class="paramname"><em>selectedAgents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remove</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a randomly ordered vector of pointers to all agents in this context. </p>
<p>If the 'remove' parameter is set to true, any elements in the original vector will be removed before the method returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">selectedAgents</td><td>a vector into which the pointers to the agents will be placed </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">remove</td><td>if true, remove any elements originally in the set before the set is returned (default is false) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a305bd5cfc509be346842567fdf72f97d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrepast_1_1_context.html">repast::Context</a>&lt; T &gt;::selectAgents </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; T * &gt; &amp;&#160;</td>
          <td class="paramname"><em>selectedAgents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remove</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a set of pointers to a specified number of randomly selected agents. </p>
<p>If the set passed contains any elements when this method is called, the agents pointed to by those elements will be omitted from the selection.</p>
<p>If the 'remove' parameter is set to true, any elements in the original set will be removed before the method returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">count</td><td>the number of agents to be selected. If this exceeds the number that can possibly be selected, all possible agents will be selected </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">selectedAgents</td><td>a set into which the pointers to the agents will be placed </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">remove</td><td>if true, remove any elements originally in the set before the set is returned (default is false) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acba9351838355a0cfe3dff074448bbc5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrepast_1_1_context.html">repast::Context</a>&lt; T &gt;::selectAgents </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T * &gt; &amp;&#160;</td>
          <td class="paramname"><em>selectedAgents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remove</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a randomly ordered vector of pointers to a specified number of randomly selected agents. </p>
<p>If the vector passed contains any elements when this method is called, the agents pointed to by those elements will be omitted from the selection.</p>
<p>If the 'remove' parameter is set to true, any elements in the original vector will be removed before the method returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">count</td><td>the number of agents to be selected. If this exceeds the number that can possibly be selected, all possible agents will be selected </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">selectedAgents</td><td>a vector into which the pointers to the agents will be placed </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">remove</td><td>if true, remove any elements originally in the set before the set is returned (default is false) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abf2012f09fb75bfdeb798431e63edfde"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrepast_1_1_context.html">repast::Context</a>&lt; T &gt;::selectAgents </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; T * &gt; &amp;&#160;</td>
          <td class="paramname"><em>selectedAgents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remove</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>popSize</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a set of pointers to all agents in this context of a specified type (per their <a class="el" href="classrepast_1_1_agent_id.html" title="Agent identity information. ">AgentId</a> values). </p>
<p>If the 'remove' parameter is set to true, any elements in the original set will be removed before the method returns.</p>
<p>The popSize parameter is used when the method is repeatedly called on a population whose size is known. Calls to this method typically begin by determining the size of the (valid) population to be sampled; if this is known, it can be provided here, improving performance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">selectedAgents</td><td>a set into which the pointers to the agents will be placed </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">type</td><td>numeric type of agent to be selected </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">remove</td><td>if true, remove any elements originally in the set before the set is returned (default is false) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">popSize</td><td>size of the population from which the sample will be drawn </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af8ca3deb5e820bf84df1dd83fdd14f2d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrepast_1_1_context.html">repast::Context</a>&lt; T &gt;::selectAgents </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T * &gt; &amp;&#160;</td>
          <td class="paramname"><em>selectedAgents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remove</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>popSize</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a randomly ordered vector of pointers to all agents in this context of a specified type (per their <a class="el" href="classrepast_1_1_agent_id.html" title="Agent identity information. ">AgentId</a> values). </p>
<p>If the 'remove' parameter is set to true, any elements in the original vector will be removed before the method returns.</p>
<p>The popSize parameter is used when the method is repeatedly called on a population whose size is known. Calls to this method typically begin by determining the size of the (valid) population to be sampled; if this is known, it can be provided here, improving performance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">selectedAgents</td><td>a vector into which the pointers to the agents will be placed </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">type</td><td>numeric type of agent to be selected </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">remove</td><td>if true, remove any elements originally in the set before the set is returned (default is false) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">popSize</td><td>size of the population from which the sample will be drawn </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8961d3bd4575afac3ef571166739ac39"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrepast_1_1_context.html">repast::Context</a>&lt; T &gt;::selectAgents </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; T * &gt; &amp;&#160;</td>
          <td class="paramname"><em>selectedAgents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remove</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>popSize</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a set of pointers to a specified number of randomly selected agents of a specified type (per their <a class="el" href="classrepast_1_1_agent_id.html" title="Agent identity information. ">AgentId</a> values). </p>
<p>If the set passed contains any elements when this method is called, the agents pointed to by those elements will be omitted from the selection.</p>
<p>If the 'remove' parameter is set to true, any elements in the original set will be removed before the method returns.</p>
<p>The popSize parameter is used when the method is repeatedly called on a population whose size is known. Calls to this method typically begin by determining the size of the (valid) population to be sampled; if this is known, it can be provided here, improving performance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">count</td><td>the number of agents to be selected. If this exceeds the number that can possibly be selected, all possible agents will be selected </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">selectedAgents</td><td>a set into which the pointers to the agents will be placed </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">type</td><td>numeric type of agent to be selected </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">remove</td><td>if true, remove any elements originally in the set before the set is returned (default is false) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">popSize</td><td>size of the population from which the sample will be drawn </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aae94abf702a7223aaadc74da4f1fd639"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrepast_1_1_context.html">repast::Context</a>&lt; T &gt;::selectAgents </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T * &gt; &amp;&#160;</td>
          <td class="paramname"><em>selectedAgents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remove</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>popSize</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a randomly ordered vector of pointers to a specified number of randomly selected agents of a specified type (per their <a class="el" href="classrepast_1_1_agent_id.html" title="Agent identity information. ">AgentId</a> values). </p>
<p>If the vector passed contains any elements when this method is called, the agents pointed to by those elements will be omitted from the selection.</p>
<p>If the 'remove' parameter is set to true, any elements in the original vector will be removed before the method returns.</p>
<p>The popSize parameter is used when the method is repeatedly called on a population whose size is known. Calls to this method typically begin by determining the size of the (valid) population to be sampled; if this is known, it can be provided here, improving performance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">count</td><td>the number of agents to be selected. If this exceeds the number that can possibly be selected, all possible agents will be selected </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">selectedAgents</td><td>a vector into which the pointers to the agents will be placed </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">type</td><td>numeric type of agent to be selected </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">remove</td><td>if true, remove any elements originally in the set before the set is returned (default is false) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">popSize</td><td>size of the population from which the sample will be drawn </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a926168c2e765e58473d901f56a6a42f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename filterStruct &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrepast_1_1_context.html">repast::Context</a>&lt; T &gt;::selectAgents </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; T * &gt; &amp;&#160;</td>
          <td class="paramname"><em>selectedAgents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">filterStruct &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remove</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>popSize</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a set of pointers to all agents in this context matching a user-defined filter. </p>
<p>If the 'remove' parameter is set to true, any elements in the original set will be removed before the method returns.</p>
<p>The popSize parameter is used when the method is repeatedly called on a population whose size is known. Calls to this method typically begin by determining the size of the (valid) population to be sampled; if this is known, it can be provided here, improving performance.</p>
<p>that can possibly be selected, all possible agents will be selected </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">selectedAgents</td><td>a set into which the pointers to the agents will be placed </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">filter</td><td>user-defined filter specifying any criteria agents to be selected must meet </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">remove</td><td>if true, remove any elements originally in the set before the set is returned (default is false) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">popSize</td><td>size of the population from which the sample will be drawn</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">filterStruct</td><td>the type of the filter to be applied to the agents </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5011ce09dc44040c235b176261defcf3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename filterStruct &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrepast_1_1_context.html">repast::Context</a>&lt; T &gt;::selectAgents </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T * &gt; &amp;&#160;</td>
          <td class="paramname"><em>selectedAgents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">filterStruct &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remove</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>popSize</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a randomly ordered vector of pointers to all agents in this context matching a user-defined filter. </p>
<p>If the 'remove' parameter is set to true, any elements in the original vector will be removed before the method returns.</p>
<p>The popSize parameter is used when the method is repeatedly called on a population whose size is known. Calls to this method typically begin by determining the size of the (valid) population to be sampled; if this is known, it can be provided here, improving performance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">selectedAgents</td><td>a vector into which the pointers to the agents will be placed </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">filter</td><td>user-defined filter specifying any criteria agents to be selected must meet </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">remove</td><td>if true, remove any elements originally in the set before the set is returned (default is false) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">popSize</td><td>size of the population from which the sample will be drawn</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">filterStruct</td><td>the type of the filter to be applied to the agents </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a10218ffcf74884be4e12c49a26106878"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename filterStruct &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrepast_1_1_context.html">repast::Context</a>&lt; T &gt;::selectAgents </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; T * &gt; &amp;&#160;</td>
          <td class="paramname"><em>selectedAgents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">filterStruct &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remove</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>popSize</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a set of pointers to a specified number of randomly selected agents matching a user-defined filter. </p>
<p>If the set passed contains any elements when this method is called, the agents pointed to by those elements will be omitted from the selection.</p>
<p>If the 'remove' parameter is set to true, any elements in the original set will be removed before the method returns.</p>
<p>The popSize parameter is used when the method is repeatedly called on a population whose size is known. Calls to this method typically begin by determining the size of the (valid) population to be sampled; if this is known, it can be provided here, improving performance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">count</td><td>the number of agents to be selected. If this exceeds the number that can possibly be selected, all possible agents will be selected </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">selectedAgents</td><td>a set into which the pointers to the agents will be placed </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">filter</td><td>user-defined filter specifying any criteria agents to be selected must meet </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">remove</td><td>if true, remove any elements originally in the set before the set is returned (default is false) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">popSize</td><td>size of the population from which the sample will be drawn</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">filterStruct</td><td>the type of the filter to be applied to the agents </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a41673cd1e0623849d505884afaaf2581"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename filterStruct &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrepast_1_1_context.html">repast::Context</a>&lt; T &gt;::selectAgents </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T * &gt; &amp;&#160;</td>
          <td class="paramname"><em>selectedAgents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">filterStruct &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remove</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>popSize</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a randomly ordered vector of pointers to a specified number of randomly selected agents matching a user-defined filter. </p>
<p>If the vector passed contains any elements when this method is called, the agents pointed to by those elements will be omitted from the selection.</p>
<p>If the 'remove' parameter is set to true, any elements in the original vector will be removed before the method returns.</p>
<p>The popSize parameter is used when the method is repeatedly called on a population whose size is known. Calls to this method typically begin by determining the size of the (valid) population to be sampled; if this is known, it can be provided here, improving performance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">count</td><td>the number of agents to be selected. If this exceeds the number that can possibly be selected, all possible agents will be selected </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">selectedAgents</td><td>a vector into which the pointers to the agents will be placed </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">filter</td><td>user-defined filter specifying any criteria agents to be selected must meet </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">remove</td><td>if true, remove any elements originally in the set before the set is returned (default is false) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">popSize</td><td>size of the population from which the sample will be drawn</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">filterStruct</td><td>the type of the filter to be applied to the agents </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2d678fd5e8a320db144d17fb863ee91a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename filterStruct &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrepast_1_1_context.html">repast::Context</a>&lt; T &gt;::selectAgents </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; T * &gt; &amp;&#160;</td>
          <td class="paramname"><em>selectedAgents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">filterStruct &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remove</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>popSize</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a set of pointers to all agents in this context of a specified type (per their <a class="el" href="classrepast_1_1_agent_id.html" title="Agent identity information. ">AgentId</a> values) and matching a user-defined filter. </p>
<p>If the 'remove' parameter is set to true, any elements in the original set will be removed before the method returns.</p>
<p>The popSize parameter is used when the method is repeatedly called on a population whose size is known. Calls to this method typically begin by determining the size of the (valid) population to be sampled; if this is known, it can be provided here, improving performance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">selectedAgents</td><td>a set into which the pointers to the agents will be placed </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">type</td><td>numeric type of agent to be selected </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">filter</td><td>user-defined filter specifying any criteria agents to be selected must meet </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">remove</td><td>if true, remove any elements originally in the set before the set is returned (default is false) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">popSize</td><td>size of the population from which the sample will be drawn</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">filterStruct</td><td>the type of the filter to be applied to the agents </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a07cf00b1c5a00b676c5de83e8db438aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename filterStruct &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrepast_1_1_context.html">repast::Context</a>&lt; T &gt;::selectAgents </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T * &gt; &amp;&#160;</td>
          <td class="paramname"><em>selectedAgents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">filterStruct &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remove</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>popSize</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a randomly ordered vector of pointers to all agents in this context of a specified type (per their <a class="el" href="classrepast_1_1_agent_id.html" title="Agent identity information. ">AgentId</a> values) and matching a user-defined filter. </p>
<p>If the 'remove' parameter is set to true, any elements in the original vector will be removed before the method returns.</p>
<p>The popSize parameter is used when the method is repeatedly called on a population whose size is known. Calls to this method typically begin by determining the size of the (valid) population to be sampled; if this is known, it can be provided here, improving performance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">selectedAgents</td><td>a vector into which the pointers to the agents will be placed </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">type</td><td>numeric type of agent to be selected </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">filter</td><td>user-defined filter specifying any criteria agents to be selected must meet </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">remove</td><td>if true, remove any elements originally in the set before the set is returned (default is false) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">popSize</td><td>size of the population from which the sample will be drawn</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">filterStruct</td><td>the type of the filter to be applied to the agents </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afe8f496266275c9edb065c06c6574fc1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename filterStruct &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrepast_1_1_context.html">repast::Context</a>&lt; T &gt;::selectAgents </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; T * &gt; &amp;&#160;</td>
          <td class="paramname"><em>selectedAgents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">filterStruct &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remove</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>popSize</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a set of pointers to a specified number of randomly selected agents of a specified type (per their <a class="el" href="classrepast_1_1_agent_id.html" title="Agent identity information. ">AgentId</a> values) and matching a user-defined filter. </p>
<p>If the set passed contains any elements when this method is called, the agents pointed to by those elements will be omitted from the selection.</p>
<p>If the 'remove' parameter is set to true, any elements in the original set will be removed before the method returns.</p>
<p>The popSize parameter is used when the method is repeatedly called on a population whose size is known. Calls to this method typically begin by determining the size of the (valid) population to be sampled; if this is known, it can be provided here, improving performance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">count</td><td>the number of agents to be selected. If this exceeds the number that can possibly be selected, all possible agents will be selected </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">selectedAgents</td><td>a set into which the pointers to the agents will be placed </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">type</td><td>numeric type of agent to be selected </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">filter</td><td>user-defined filter specifying any criteria agents to be selected must meet </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">remove</td><td>if true, remove any elements originally in the set before the set is returned (default is false) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">popSize</td><td>size of the population from which the sample will be drawn</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">filterStruct</td><td>the type of the filter to be applied to the agents </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab4aea4be7eaf1c4be741a371e90057a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename filterStruct &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrepast_1_1_context.html">repast::Context</a>&lt; T &gt;::selectAgents </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T * &gt; &amp;&#160;</td>
          <td class="paramname"><em>selectedAgents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">filterStruct &amp;&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remove</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>popSize</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a randomly ordered vector of pointers to a specified number of randomly selected agents of a specified type (per their <a class="el" href="classrepast_1_1_agent_id.html" title="Agent identity information. ">AgentId</a> values) and matching a user-defined filter. </p>
<p>If the vector passed contains any elements when this method is called, the agents pointed to by those elements will be omitted from the selection.</p>
<p>If the 'remove' parameter is set to true, any elements in the original vector will be removed before the method returns.</p>
<p>The popSize parameter is used when the method is repeatedly called on a population whose size is known. Calls to this method typically begin by determining the size of the (valid) population to be sampled; if this is known, it can be provided here, improving performance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">count</td><td>the number of agents to be selected. If this exceeds the number that can possibly be selected, all possible agents will be selected </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">selectedAgents</td><td>a vector into which the pointers to the agents will be placed </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">type</td><td>numeric type of agent to be selected </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">filter</td><td>user-defined filter specifying any criteria agents to be selected must meet </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">remove</td><td>if true, remove any elements originally in the set before the set is returned (default is false) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">popSize</td><td>size of the population from which the sample will be drawn</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">filterStruct</td><td>the type of the filter to be applied to the agents </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9470dbe20a0b4243d52edea86c213feb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrepast_1_1_context.html">repast::Context</a>&lt; T &gt;::setProjectionInfo </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; std::string, std::vector&lt; <a class="el" href="classrepast_1_1_projection_info_packet.html">repast::ProjectionInfoPacket</a> * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>projInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the projection information as specified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">projInfo</td><td>map where keys represent projections in this context and the values represent collections of projection information content that will be used to specify the relationships among the agents. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>repast_hpc/<a class="el" href="_context_8h_source.html">Context.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Aug 11 2013 12:21:28 for Repast HPC by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.4
</small></address>
</body>
</html>
